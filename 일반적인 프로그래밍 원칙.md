# Item59. 라이브러리를 익히고 사용하라

### Why??

- 코드를 작성한 전문가의 지식과 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
- 핵심적인 비즈니스 개발에만 집중할 수 있다.
- 노력하지 않아도 성능이 지속적으로 개선된다.
- 기능이 점점 많아진다.



### 익혀두면 좋은 라이브러리

- 컬렉션 프레임워크
- 스트림 라이브러리
- Java.util.concurrent



# Item60. 정확한 답이 필요하다면 float과 double은 피하라

### Why??

- float과 double은 넓은 범위의 수를 빠르게 연산하여 근사치를 계산하도록 설계되었다. => 정확한 값을 목적으로 설계된 것이 아니다.



### 해결책은?

- BigDecimal, int, long을 사용하면 된다.
- BigDecimal
  - 정확한 값을 계산할 수 있다.
  - 범위가 크다.
  - 하지만 기본 타입보다 쓰기 불편하고, 느리다.
- Int, long
  - 사용이 BigDecimal에 비해 간편하다.
  - 하지만 크기가 제한되고, 소수점을 직접 관리해야 한다.
    - 예를 들어 달러 기준으로 계산하던 돈을 센트 기준으로 계산해야 한다. (1.03달러 => 103센트)







# Item63. 문자열 연결은 느리니 주의하라

### 결론

- 변하는 문자열이라면 String 대신 StringBuilder 혹은 StringBuffer를 사용하라.



### Why?

- String의 가장 큰 특징은 불변성이다.

  ```java
  String str = "I am a";
  str += "human";
  ```

  - 참조 변수 str이 가리키는 곳에 저장된 값이 I am a에서 I am a human으로 변하는 것이 아니라 Heap영역에 "I am a human"값이 새로 생성되고 str이 가리키는 주소가 달라진다. 이후 "I am a"는 GC 처리를 기다리게 된다.

- 이러한 특성 때문에 가변성 문자열은 StringBuilder / StringBuffer를 사용해야 보다 나은 성능을 얻을 수 있다



















# Item64. 객체는 인터페이스를 사용해 참조하라

```java
LinkedHashSet<String> stringSet = new LinkedHashSet<>(); // 보다는

Set<String> stringSet = new LinkedHashSet<>(); //를 사용하라!
```



### Why?

- 변경에 용이하다.
  - 예를 들어 stringSet을 HashSet<>()으로 바꿔야 한다면, 생성자만 교체하면 된다.
    - 또한 기존 타입에서만 제공하는 메서드 사용으로 인해 컴파일이 되지 않는 상황을 막을 수 있다.
  - 단, 인터페이스 일반 규약 이외의 특별한 기능이 있었고, 주변 코드가 이 기능을 활용했다면 새로운 클래스도 반드시 같은 기능을 제공해야 한다.
    - Ex) LinkedHashSet의 순서 정책을 이용하다가 HashSet으로 바꾼다면 문제가 될 수 있다.





### 적합한 인터페이스가 없다면?

- 적합한 인터페이스가 아예 없는 경우 클래스를 참조 타입으로 사용해도 무방하다.
  - 값 클래스
  - 클래스 기반으로 작성된 프레임워크 제공 객체 (OutputStream 등)
  - 특별한 메서드를 제공하는 클래스 (PriorityQueue 등)

- 적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자!





