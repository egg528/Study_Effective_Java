## Item3. private 생성자나 Enum TYPE으로 Singleton을 보증하라

### Singleton을 어떻게 보장할 수 있을까?  
- Singleton이란?
  - 인스턴스를 오직 하나만 생성할 수 있는 클래스를 뜻한다.  
  
  
#### `public static final field 방식의 Singleton`
```java 
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
            
    private Elvis(){}        
}
```
- 장점
  - public static final이라는 점이 해당 클래스가 Singleton임을 명백히 드러냄
  - 추가적인 메서드 작성이 필요 없기에 코드가 간결하다.
- 단점
  - 리플렉션 API인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출할 수 있다.
  - Serialize을 위해서는 readResolve 메서드를 구현해야 한다.
    

#### `static factory 방식의 Singleton`
```java 
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
            
    private Elvis(){}
    
    public static Elvis getInstance(){ return INSTANCE; }        
}
```
- 장점
  - API를 바꾸지 않고 Singleton이 아니게 변경할 수 있다 ***?
  - generic singleton factory로 변경 가능하다.
    - ```java 
      public class Elvis<E> {
          private static final ArrayList INSTANCE = new ArrayList<>();

          private Elvis(){}

          public static <E> ArrayList<E> getInstance(){
              return (ArrayList<E>) INSTANCE;
          }
      }
      ```
  - 메서드 참조를 supplier에 활용할 수 있다. (Elvis::getInstance)
- 단점
  - 리플렉션 API인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출할 수 있다.
  - Serialize을 위해서는 readResolve 메서드를 구현해야 한다.
     

#### ` Enum 방식의 Singleton`
```java 
public enum CEO {
    INSTANCE;

    private String name;

    public CEO getInstance(){
        return INSTANCE;
    }

    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }
}
```
- 장점
  - 리플렉션 공격에서도 제 2의 인스턴스가 생기는 일이 없다.
  - 추가적인 메서드 작성 없이 직열화가 가능하다.
- 단점
  - Enum 외의 클래스를 상속해야 할 때는 사용할 수 없다.
  - Enum의 원래 취지와는 다른 방식의 사용이기에 쉽게 파악하지 못할 수 있다.