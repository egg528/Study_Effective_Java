# Item16. 상속보다는 컴포지션을 사용하라

###   

### (다른 패키지의) 구체 클래스를 상속하는 일은 위험하다. 왜?

- 상속은 캡슐화를 깨뜨린다. (결합도 증가)

  - A 클래스를 B 클래스가 상속 받았다고 가정하자.

  - B클래스는 A클래스에 영향을 받을 수밖에 없다.

  - ```java
    public class InstrumentedHashSet<E> extends HashSet<E> {
        private int addCount = 0;
    
        public InstrumentedHashSet(){};
    
        @Override
        public boolean add(E e){
            addCount++;
            return super.add(e);
        }
    
        @Override
        public boolean addAll(Collection<? extends E> c){
            addCount += c.size();
            return super.addAll(c);
        }
    
        public int getAddCount(){
            return addCount;
        }
    
        public static void main(String[] args) {
            InstrumentedHashSet hs = new InstrumentedHashSet();
            List<Integer> list = new ArrayList<>();
            list.add(1);
            list.add(2);
            list.add(3);
    
            hs.addAll(list);
    
            System.out.println(hs.getAddCount());  // 6
        }
    }
    ```

  - hs.getAddCount() 값이 3이 나올 것이라 예상하지만, 출력은 6이 나온다.

  - 이유는 HashSet의 addAll 메서드에서 Collection의 원소를 넣을 때 사용하는 메서드가 재정의된 add이기 때문이다 (self-use - 자기 사용).

  - 위 예시는 InstrumentedHashSet은 상위 클래스인 HashSet의 구현에 영향을 받을 수밖에 없다는 하나의 근거이다.

  - 만약 새로운 릴리즈에서 어떠한 클래스를 수정하게 된다면 하위 클래스는 모두 이에 영향을 받게 되기 때문에 클래스간 관계를 복잡하지 않게 유지하기 위해서는 다른 패키지의 구체 클래스를 상속하지 않는 것이 좋다.



### 해결책은?

```
컴포지션과 전달 방식을 사용하자!
```



컴포지션이란?

- 기존의 클래스가 새로운 클래스의 구성요소로 쓰이는 설계 방식을 뜻한다.
- 즉, 기존 클래스를 확장하는 대신 새로운 클래스의 private 필드로 참조하여 사용하는 방식.



전달이란?

- 새로운 클래스의 메서드들 구현할 때 이에 대응하는 기존 클래스의 메서드를 호출해 결과를 반환하는 방식을 ''전달"이라 한다.

### 

예시

```java
// 재사용 가능한 전달 클래스

public class ForwardingSet<E> implements Set<E>{
  private final Set<E>;
  
  public ForwardingSet(Set<E> s) {this.s = s;}
  
  public boolean add(E e) {return s.add(e);}
  
  public boolean addAll(Collection<? extends E> c){ return s.addAll(c);}
  
  ...
}
```



```java
// 래퍼 클래스 - 상속 대신 컴포지션을 사용

public class InstrumentedSet<E> extends ForwardingSet<E>{
  private int addCount = 0;
  
  public InstrumentedSet(Set<E> s) {
    super(s); //
  }
  
  
  @Override
  public boolean add(E e) {
    addCount++;
    return super.add(e);
  }
  
  
  @Override
  public boolean addAll(Collection<? extends E> c){ 
    addCount += c.size;
    return super.addAll(c);
  }
  
  ...
}
```



```java
// 실행 코드

public static void main(String[] args) {
        InstrumentedSet hs = new InstrumentedSet(new HashSet());
        List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);

        hs.addAll(list);

        System.out.println(hs.getAddCount());  // 3
}
```



- 위 설계의 핵심은 InstrumentedSet의 생성자 인자로 받은 Set 인스턴스 기능을 활용해 InstrumentedSet 메서르들 만들었다는 것이다.
- Composition을 활용한 구현의 장점은 여럿이다.
  - 1. 다양한 구현체를 인자로 받아 기능에 활용할 수 있게 된다.
       - 예를 들어 HashSet 대신에 TreeSet 등 Set의 다양한 하위 구현체를 사용하여 새로운 클래스를 구성할 수 있게 된다.
    2. 상위 클래스의 생성자 각각에 대응하는 생성자를 별도로 정의할 필요가 없다.
       - 내부 구성 요소로 HashSet을 이요하던 TreeSet을 이용하던 하나의 생성자를 이용해 인스턴스를 생성할 수 있다.
    3. 상위 클래스의 구현 방식(재정의 시 위험성) 혹은 변경에 의한 하위 클래스 활용의 오류를 제거해준다.
       - 예를 들어 새로운 릴리즈에서 HashSet의 특정 메서드 구현이 바뀌었다고 해도 Composition 방식은 HashSet의 메서드를 그대로 이용하기 때문에 문제가 되지 않는다.
- 단, 콜백 프레임워크와는 어울리지 않는다는 점만 주의하면 된다.
  - 콜백 함수이란?
    - 다른 함수의 인자로써 이용되는 함수
    - 어떤 이벤트에 의해 호출되어지는 함수
  - 콜백 함수의 첫번째 정의에 초점을 맞춰, 콜백 프레임 워크란 자기 자신의 참조를 다른 객체에 넘겨 다른 객체에 의해 사용되는 구조로 이해하였다.
  - 이러한 상황에서 래퍼 내부의 객체는 래퍼의 존재를 알지 못하기에 래퍼 클래스를 거치지 않고 자신을 참조할 경우 문제가 생길 수 있다 (SELF 문제)





### 그렇다면 상속은 언제 사용해야 할까?

상속은 진짜 하위 타입인 경우 즉, is-a 관계일 경우에만 사용해야 한다.

- 컴포지션을 써야 할 상황에서 상속을 사용할 경우 생길 수 있는 단점들
  - 내부 구현을 불필요하게 노출하게 되고 직접 접근도 가능해진다.
  - 상위 클래스를 직접 수정하여 하위 클래스의 불변식을 깨버릴 수 있다.



상속을 사용하기로 결정하기 전 고민해볼 것

- 확장하려는 클래스의 API는 아무런 결함이 없는가?
- 결함이 있다면 새로운 클래스까지 전파돼도 괜찮은가?

